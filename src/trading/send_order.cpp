// Note: Headers are included in binacpp_modular.cpp

/*
        Author: blackb1rd
        Date  : 2025/08/07
        Based on original work by tensaix2j (2017/10/15)

        C++ library for Binance API - Send Order
        POST /api/v3/order - Send new order (SIGNED)
        
        Parameters:
        - symbol: STRING (YES)
        - side: ENUM (YES)
        - type: ENUM (YES)
        - timeInForce: ENUM (YES)
        - quantity: DECIMAL (YES)
        - price: DECIMAL (YES)
        - newClientOrderId: STRING (NO) - A unique id for the order. Automatically generated by default
        - stopPrice: DECIMAL (NO) - Used with STOP orders
        - icebergQty: DECIMAL (NO) - Used with icebergOrders
        - recvWindow: LONG (NO)
        - timestamp: LONG (YES)
*/

// Note: Headers are included in binacpp_modular.cpp

void BinaCPP::send_order(std::string_view symbol,
                         std::string_view side,
                         std::string_view type,
                         std::string_view timeInForce,
                         double quantity,
                         double price,
                         std::string_view newClientOrderId,
                         double stopPrice,
                         double icebergQty,
                         long recvWindow,
                         Json::Value &json_result) {
  BinaCPP_logger::write_log("<BinaCPP::send_order>");

  if (api_key.size() == 0 || secret_key.size() == 0) {
    BinaCPP_logger::write_log(
        "<BinaCPP::send_order> API Key and Secret Key has not been set.");
    return;
  }

  std::string url(BINANCE_HOST);
  url += "/api/v3/order?";

  std::string action = "POST";

  std::string post_data("symbol=");
  post_data.append(symbol);

  post_data.append("&side=");
  post_data.append(side);

  post_data.append("&type=");
  post_data.append(type);
  if (type != "MARKET")  // type != MARKET
  {
    post_data.append("&timeInForce=");
    post_data.append(timeInForce);
    post_data.append("&price=");
    post_data.append(std::to_string(price));
  }
  post_data.append("&quantity=");
  post_data.append(std::to_string(quantity));

  if (!newClientOrderId.empty()) {
    post_data.append("&newClientOrderId=");
    post_data.append(newClientOrderId);
  }

  if (stopPrice > 0.0) {
    post_data.append("&stopPrice=");
    post_data.append(std::to_string(stopPrice));
  }

  if (icebergQty > 0.0) {
    post_data.append("&icebergQty=");
    post_data.append(std::to_string(icebergQty));
  }

  if (recvWindow > 0) {
    post_data.append("&recvWindow=");
    post_data.append(std::to_string(recvWindow));
  }

  post_data.append("&timestamp=");
  post_data.append(std::to_string(get_current_ms_epoch()));

  std::string signature = hmac_sha256(secret_key.c_str(), post_data.c_str());
  post_data.append("&signature=");
  post_data.append(signature);

  std::vector<std::string> extra_http_header;
  std::string header_chunk("X-MBX-APIKEY: ");
  header_chunk.append(api_key);
  extra_http_header.push_back(header_chunk);

  BinaCPP_logger::write_log(
      "<BinaCPP::send_order> url = |%s|, post_data = |%s|",
      url.c_str(),
      post_data.c_str());

  std::string str_result;
  curl_api_with_header(url, str_result, extra_http_header, post_data, action);

  if (str_result.size() > 0) {
    try {
      Json::Reader reader;
      json_result.clear();
      reader.parse(str_result, json_result);

    } catch (std::exception &e) {
      BinaCPP_logger::write_log("<BinaCPP::send_order> Error ! %s", e.what());
    }
    BinaCPP_logger::write_log("<BinaCPP::send_order> Done.");

  } else {
    BinaCPP_logger::write_log("<BinaCPP::send_order> Failed to get anything.");
  }

  BinaCPP_logger::write_log("<BinaCPP::send_order> Done.\n");
}
